This presentation is in charge of the Stanford Center for Professional Development. Here is in a few words a reduced version of what is presented in the hand as well. This is the curriculum.. I have several languages that I'm going to put on the board in just M1 concept. C assembly C++ concurrent programming. That's not a language that's just a paradigm.. I'm gonna cover Python from now on at 107.. People look at this and say, wow, I'm gonna be able to legitimately put all these languages in my resume.. This comma is a list at the bottom and feels great. It's not that much of a deal.. We certainly want to give you some mileage in some very relevant languages that are very good for both research and industry.. The real intellectual value in learning all these languages is to really study the paradigms they represent.. I'll explain what that means in a second.. But programming in C or C++ is actually almost a process of thinking different from what you are when programs in scheme or Python. You all know enough C++ and believe it or not already know a lot about C. You just need to get the orientation out of the C++ object and you're more or less left with C.. When you program in C, you don't have classes. You're very procedurally oriented.. You think of the main function as a high-level profile of maybe five higher-level functions to call and those five functions have sub-functions and those sub-functions have sub-functions, etc.. Makes sense.. It's like a sketch for history.. What outlined notes for the history class where you have Roman number one and main and Roman number two and main and Roman number three and main and you have small A and B and they have little A and things like that. Do you understand what I mean?. Program with side effects. You pass around references and pointers with the idea of updating shared data. You do it both in C and C++, but as far as C is concerned, this represents what is called the procedural paradigm.. It is also heard that it is called the imperative paradigm. It's verb oriented in the sense that the first thing you see or do normally do with a statement is the function called where the name of the function is usually has some strong verb in it so it gives some ideas to what the function is supposed to achieve.. Does it make sense to people? When you studied C++ and suddenly instead of calling do this and pass the direction of some object, you make my object arrow do this. So, all of a sudden, the first thing you see in that line is the data or the object that's being manipulated and because the first thing you see is the object, that's why it's object-oriented instead of procedure-oriented.. That makes sense to people.. I think that many C++ programmers actually program in C and, by the way, use objects in classes that are available to them, which is a perfectly reasonable way to program.. Most people learn to have a program in C. Most people I know in the industry know C very, very well and despite the fact that there are 50 million newer languages that are better in many ways, they still stick to what they know and that's why C and C++ are still so popular languages. There's nothing wrong with programming in C if you really know that very well and write clean readable code. It's harder.. I'm sorry, let's say it's a lot easier to make C memory errors because everything is exposed and there's very little error checking and moving on.. C++ is a little better about it. In the middle of here I have this thing called assembly.. I haven't decided if I'm going with what I've been with for the last seven or eight years, which is this simulated assembly language or I'm going to take a step and teach you a real one, I don't mean it's, it's a real assembly language even though you don't see it as in use a lot.. But there is an assembly language called MIPS that is very easy as far as the assembly languages are going to learn. I really don't care so much about teaching how to schedule an assembly.. I use it as a vehicle to show you how C and C++ programs are compiled to .O and the object files in binary and eventually become executable and show you how a line like i is equal to seven or j++ or foo of x e and as a function call, how all that translates to assembly code. Do you know that when you write C++ code, when you run the program it's no longer C++, it's assembly code.. It's all zeros and some eventually.. I want to give you an idea of how C translates into the assembly code, how all the variables and their functions and their objects and all of that eventually comes down to a collection of zeros and ones.. And I want to do a little of the same for C++.. It turns out that well C++ and C represent different paradigms that actually all still compile to zeros and ones.. And after getting enough experience with mounting and manual compilation process that we're going to learn about is how to look at C code and figure out what the mounting code would be like.. We're really going to see that C++ and C almost look the same language when it comes to zeros and ones.. We're really going to extend the build model that we use to go from C to assembly to accommodate references and C++ classes and templates and stuff so they're new to language compared to C.. And you have a, I think a very, very good understanding of how C and C++ work after the first five weeks of the course.. It makes you much better a C and C++ program where we're going to demystify all this from the pointer.. I'll be able to do something like asterisk, asterisk, amperisco, asterisk, asterisk, arrow p, asterisk, asterisk, asterisk, asterisk, asterisk, equal to seven. And you're gonna know exactly what that means.. And so it takes a little work and it's almost laughable how arbitrary it can be with all its plaster and its amperands and its asterisk. But if it's compiled, it means something.. So when it runs, it actually does something.. It's probably not good if you have a lot of asterisk and ampersands.. And unless you can have any idea why he's crushing, not just that he's crushing.. I spend a good amount of energy talking about concurrent programming. Actually, for the moment, we do that kind of programming in C.. But all the programs you've written in the last two quarters, if you just took the 106th and 106b courses here, it's 106x.. All the programs you've written in Stanford before 107 have been sequential programs, which means either object- or imperative-oriented, or procedural-oriented, you have this scheme of steps that happen one after the other.. Nothing is done in parallel or pipe or stunning side by side. Everything happens in a clean flow of instructions. Well, what concurrent programming is all about is within a single program, trying to get two functions to apparently run simultaneously.. And if you can get two functions that apparently run simultaneously, then you can extend and get 10 functions that run simultaneously, or 20 functions that run simultaneously, or apparently simultaneously, I say it that way because technically they don't run at the same time.. When I review the assembly code, and I think you can intuit enough about what the assembly code is like, but if you have this function, my hand is a function, this hand is another function.. And you worry about the execution of one of them.. So when I do this, you can think about reading the code and running it for side effects.. That makes sense to people.. When you do with concurrent programming, you have two or more functions, just two here, because I only have two hands, to do this, and both apparently run at the same time.. But what really happens is that it's like watching two movies at the same time, where because there's only one processor on most machines, it doesn't really work that way, it runs that way, and it changes back and forth between the two functions.. But it happened so fast, you can't see the difference.. It's more than 24 frames per second.. It's like a million.. And you're watching two movies at the same time.. And that only extends fine to three to five to ten to 100 in theory.. Many situations in which concurrent programming is not really very useful, but there are several situations, particularly networking, when that is involved, where concurrent programming is really very useful. There are some problems that arise when it comes to concurrent programming that you cannot think about. The example I always go over the first day of class is just that it uses two Wells Fargo ATMs. Think you have a current account, Wells Fargo.. Maybe you don't think about it because you probably do.. So imagine that your check account is in danger because two people are using ATMs, and you have $100 in it.. And you share your pin with your best friend and you go up to the neighboring ATMs, and you make as much progress as possible to withdraw that $100, and then both on the count of three press OK to try and get $200 collectively.. That's not a pointless example because both machines are basically very simple computers.. That ultimately needs access, the same balance of the main account, to confirm that $100 is available, and in this transactional way, transactional makes sense both in terms of money and also in the sense of concurrent programming. You have to make sure that the $100 you identify as the balance of the account is maintained with a certain atomic flavor so that if you have two people trying to withdraw $100 at the same time, that only one person gets away with it.. That $100 account balance is the shared resource that two different processes have access to. Does that make sense to people? So there have to be directives that are set in motion to make sure that checking the account balance and withdrawal are done basically or not at all or in its entirety so that it really works as a transaction, both in the financial sense and concurrent programming.. If you're careless about it, and it's not, I mean careless, that's not a very nice thing to say on the first day.. If you're not careful about how you really program the use, if you program at the same time, you can really get in trouble and have these data integrity issues, that banks are really very, very concerned, obviously don't want to give $10 million when they only have a million dollars.. The same with airlines. If they have one remaining seat on a flight and two people call and try to get that seat, they'll just want to give it to one person.. Now it seems they don't care about concurrent programming because they're more than happy to give you a seat that doesn't exist on the plane.. But the airline's problems are probably not related to concurrent programming.. As far as the scheme and Python are concerned, once we go through concurrent programming, we really change gear and start looking at this language called the scheme.. You may not have heard of this.. If you haven't heard of this, you may have heard of a language called Lisp, which is certainly related to. This is a representative of what is called the functional paradigm.. There are two things about schema and functional languages, purely functional languages that are interesting in contrast to CNC++. When you program using the functional paradigm, you always rely on the return value of a function to move forward.. And your programs with no side effects.. That's a very rare thing to hear as an expression when you've only coded for a year.. But when encoded in CNC++, it's very often all about side effects. The return value doesn't always tell you a lot.. It's a number or it's boolean.. But when passed in a data structure by reference to a function and updated so that when the function returns, the original data structure has been changed. That makes sense? Mm-hmm. That's side-effect programming.. Well, the idea with the scheme, and particularly the functional paradigm, is that it's not programmed with side effects.. You don't have that at all, that you always synthesize the results or partial results that become larger partial results that eventually become the result you're interested in.. And only then is it allowed to print it on the screen to see what was the answer to the problem. It's very difficult to explain the scheme if you've never seen it before in a five-minute segment of a complete introduction.. But when you get there, we have tons of examples of the paradigm.. It's a very funny and clean language to work on.. I think it's the easiest language of the four because it's such a small language.. Once you get the paradigm down and you understand how to program functionally, scheme is not so bad at all.. It's actually so much fun.. It's not that all programming is fun, but the scheme is particularly fun.. Now, I used to teach or some advanced C++ or more recently some Java towards the end of the course. Last quarter, I literally decided in the eighth week that I wasn't going to do Java because 108 is all about Java, and I felt like I was stealing the 108 thunder.. So I just said, you know what, I'm gonna teach Python.. Let's see how it works.. And I made it into the job pretty good, certainly considering I'd never taught it before.. But this language called Python, I suspect most people have heard of it, even if they've never seen it, seems to be the language of rage in a lot of significant companies in the Bay Area.. They're very smart people from these companies.. So when they use the language and they like it, there's usually a very good reason for them to like it.. You've probably heard of a language called Pearl.. It's not a very nice language.. You can think in some sense, Python being a more modern, object-oriented version of Pearl.. I don't know, Pearl, you don't know Python.. It means nothing to you.. But just understand that this is the little sexy language that has existed for probably 16, 17 years, which has really established itself as a popular language since 2000, 2001. I know a lot of people who work on Google that show on Python every day.. There is a subset of us on Facebook, the program on Python every day, doing a lot of work on distributed systems, and only Python seems to be the way to do it right there.. It actually has a lot of good libraries to deal with web programming.. Web programming can seem really boring to a lot of people because it looks like it's HTML and web pages and stuff.. Real web programming is more sophisticated than that.. Generate dynamic content-based web pages and databases and stuff like that. And Python being a scripting language, which means it's interpreted and something like that, you can write things as you go and recognize and read and execute things as you write. It's really good for that kind of thing and if everything goes well, which means that I have time to develop this task that I have, this assignment idea that I have, you're going to write a small miniature dynamic web server in Python for your final project.. It won't be sophisticated.. You're not going to write all Apache, but you're probably going to write a little thing where you really have a web server behind the scenes, making decisions about how to build an HTML page and serve it to a client.. So it will be an opportunity to learn Python, to learn your libraries, to see that as a language because you are quite young, you have the advantage of not bothering to include C and C++ and Java errors.. So he says, no, I'm gonna leave that part and I'm gonna go with this more interesting, well-formed core.. It has large libraries. It has object orientation. You can schedule, procedurally if you want and simply program as if you were in C using Python syntax. There are even aspects of functional programming in the language. So even though the syntax is different from the schema, conceptually you can use schema as Python code ideas if you want.. I'll be able to illustrate the client server paradigm and how it's different from traditional programming.. That's not so much a Python thing, but Python is a good vehicle to learn that thing.. I'll show you the library so you can analyze XML and HTML and you can understand the HTTP protocol and all these things and just to read blogs, to download RSS files, all these things that are very, very funnyly handled by Python programs.. So that's where I hope to take people by week 10 of the course.. Does that make sense?. There are some other paradigms that aren't represented here, but I think I really cover all of those that you're likely to see over the next 15 years if you come out in your repellent.. There are a couple of languages that I can briefly mention on the last day that are just fun, but they all have some overlap with some language that is represented here.. Are you all right?. So I don't like to start with any real material when I only have 10 minutes left, so I'm actually gonna let you go.. But I recognize that Friday, I'll have tons of alms for you.. I'm gonna have a mission.. Okay.. Let's dive into the low-level CNC++ pointer material. Have a good week.. Okay?