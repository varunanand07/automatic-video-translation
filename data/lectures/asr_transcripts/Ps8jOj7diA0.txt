 This presentation is delivered by the Stanford Center for Professional Development. Here is in a nutshell a reduced version of what's presented in hand out too. This is the syllabus. I have several languages I'm going to put on the board in just M1 concept. C assembly C++ concurrent programming. That's not a language that's just a paradigm. I'm going to cover Python from now on in 107. People look at this and they go, wow, I'm going to be able to legitimately put all of these languages on my resume. This comma is a list at the bottom and it feels really good. It isn't so much about that. Certainly we want to give you some mileage in some very relevant languages that are very good for both research and for industry. The real intellectual value in learning all of these languages is to really study the paradigms that they represent. I'll explain what that means in a second. But to program in C or C++ it's actually almost a different thought process than you are when you program in scheme or in Python. You all know enough C++ and believe it or not you know a lot of C already. Just take out the object orientation from C++ and you're more or less left with C. When you program in C, you have no classes. You're very procedure oriented. You think about the main function as being a high level outline of maybe five top level functions to call and those five functions have sub functions and those sub functions have sub functions etc. It makes sense. It's like outline for history. What outlined notes for history class where you have Roman number one and main and Roman number two and main and Roman number three and main and you have small A and B and they have little A and things like that. You understand what I'm getting at? You're oriented around the procedures. You program with side effects. You pass around references and pointers with the idea of updating shared data. You do that both in C and C++ but as far as C is concerned, this represents what's called the procedural paradigm. You also hear it called the imperative paradigm. It is verb oriented in the sense that the first thing you ever see or do typically see with a statement is the function call where the function name is usually has some strong verb in it so it gives you some ideas to what the function is supposed to accomplish. Does that make sense to people? When you studied C++ and all of a sudden rather than calling do this and passing the address of some object, you do my object arrow do this. Does that make sense? Then all of a sudden the first thing you see on that line is the data or the object that's being manipulated and because the first thing you see is the object, that's why it's object oriented as opposed to procedural oriented. That makes sense to people. I think a lot of C++ programmers really program in C and just incidentally use the objects in classes that are available to them, which is a perfectly reasonable way to program. Most people learn to have a program in C. Most people I know in industry know C very, very well and in spite of the fact that there's 50 million newer languages that are better in many regards, they still stick with what they know and that's why C and C++ are still such popular languages. There's nothing wrong at all with programming in C if you really know it very well and you write clean readable code. It's just more difficult. I'm sorry, let's say it's much easier to make memory errors in C because everything is exposed and there's very little error check and going on. C++ is a little bit better about it. In between here I have this thing called assembly. I haven't decided whether I'm going to go with what I've gone with for the past seven or eight years, which is this mock assembly language or I'm going to really take a step and teach you a real, I don't want to say it's, it is a real assembly language although you don't see it as in use very much. But there's a assembly language called MIPS which is very easy as far as assembly languages go to learn. I don't really care so much about teaching how to program an assembly. I use it as a vehicle for showing you how C and C++ programs compile to .O and object files into binaries and eventually become executables and show you how a line like i equals seven or j++ or foo of x and y as a function call, how that all translates to assembly code. Does that make sense? You know that when you write C++ code, when you execute the program it's not C++ anymore, it's assembly code. It's all zeros and ones eventually. I want to give you some insight as to how C is translated to assembly code, how all the variables and your functions and your objects and all of that eventually get boiled down and hashed down to a collection of zeros and ones. And I want to do a little bit of the same thing for C++. It turns out that well C++ and C represent different paradigms that they really all still compile to zeros and ones. And after you get enough experience with the assembly and the manual compilation process that we're going to learn about is how to look at C code and figure out what the assembly code would look like. We're really going to see that C++ and C almost look like the same language as far as the zeros and ones are concerned. We're really going to extend the compilation model we use for going from C to assembly to accommodate C++ references and classes and templates and things like that that are new to the language compared to C. And you have an, I think a very, very good understanding of how C and C++ work after the first five weeks of the course. It makes you so much better of a C and C++ program where we're going to demystify this whole pointer thing. I'm going to be able to do something like asterisk, asterisk, ampersand, asterisk, asterisk, p arrow, asterisk, asterisk, asterisk, asterisk, asterisk, equal seven. And you're going to know exactly what it means. And so it takes a little bit of work and it's almost laughable how arbitrary you can be with all your casts and your ampersands and your asterisk. But if it compiles, it means something. So when it runs, it actually does something. It's probably not good if you have a lot of asterisk and ampersands. And unless you can have some idea as to why it's crushing, not just that it is crushing. I spend a good amount of energy talking about concurrent programming. We actually, at the moment, do that type of programming in C. But all the programs you've written in the past two quarters, if you've just taken the 106a and 106b courses here, are 106x. All the programs you've written at Stanford prior to 107 have been sequential programs, which means whether it's object oriented or imperative, or procedurally oriented, you have this outline of steps that happen one after another. Nothing's done in parallel or pipeline or stun side by side. Everything happens in one clean stream of instructions. Well, what concurrent programming is about is within a single program, trying to get two functions to seemingly run simultaneously. And if you can get two functions to seemingly run simultaneously, then you can extend that and get 10 functions to run simultaneously, or 20 functions to run simultaneously, or seemingly simultaneously, I say it that way because technically they don't run at the same time. When I go over assembly code, and I think you can intuit enough about what assembly code is like, but if you have this one function, my hand is a function, this hand is another function. And you concern yourself with the execution of one of them. Then when I do this, you can just think about it reading the code and executing it for side effects. That makes sense to people. When you do with concurrent programming, you have two or more functions, just two right here, because I only have two hands, to do this, and they both seemingly run at the same time. But what really happens is it's like watching two movies at the same time, where because there's only one processor on most machines, it doesn't really run like this, it runs like this, and switches back and forth between the two functions. But it's happened so fast that you just can't see the difference. It's more than 24 frames per second. It's like a million. And you're watching two movies at the same time. And that extends just fine to three to five to 10 to 100 in theory. A lot of situations where concurrent programming is really not very useful, but there are several situations, particularly networking, whenever that's involved, where concurrent programming is actually very useful. There are some problems that come up when you deal with concurrent programming that you might not think about. The example I always go over the first day of class is just it uses two Wells Fargo ATM machines. Think about you have a Wells Fargo checking account. You may not think about it because you probably do. So just imagine your checking account is in danger because two people are using ATM machines, and you have $100 in it. And you share your pin with your best friend and you go up to neighboring ATM machines, and you make as much progress as possible to withdraw that $100, and then you both on the count of three press OK to try and get $200 collectively. Does that make sense? That is not a nonsensical example because both of those machines are basically very simple computers. That ultimately need access, the same master account balance, to confirm that $100 is available, and in this transactional way, transactional makes sense both in terms of money and also in the sense of concurrent programming. You have to make sure that the $100 being identified as the account balance is maintained with some atomic flavor so that if you have two people trying to withdraw $100 at the same time, that only one person gets away with it. That $100 account balance is the shared resource that two different processes have access to. Does that make sense to people? So there have to be directives that are put in place to make sure that the account balance check and the withdraw are basically done either not at all or in full so that it really does function truly as a transaction, both in the finance and the concurrent programming sense. If you're sloppy about it, and it's not, I mean sloppy, that's not a very nice thing to say on the first day. If you're not careful about how you actually program using, if program concurrently, you actually can come up with problems and have these data integrity issues, which banks are actually very, very worried about, obviously they don't want to give out $10 million when they only have a million dollars. Same thing with airlines. If they have one seat remaining on a flight and two people call and try to get that seat, they will only want to give it to one person. Now it would seem they don't care about concurrent programming because they're more than happy to give you a seat that doesn't exist on the plane. But the airline's problems are probably not related to concurrent programming. As far as the scheme and Python thing are concerned, once we get through concurrent programming, we really switch gears and we start looking at this language called scheme. You may not have heard of this. If you haven't heard of this, you may have heard of a language called Lisp, which it's certainly related to. This is a representative of what is called the functional paradigm. There's two things about scheme and functional languages, purely functional languages that are interesting in contrast to CNC++. When you program using the functional paradigm, you always rely on the return value of a function to move forward. Okay? And you program without side effects. Now that's a very weird thing to hear as an expression when you've only coded for a year. But when you code in CNC++, it's very often all about side effects. The return value doesn't always tell you very much. It's a number or it's a Boolean. But when you pass in a data structure by reference to a function and you update it so that when the function returns, the original data structure has been changed. Right? Does that make sense? That's programming by side effect. Well, the idea with scheme, and particularly the functional paradigm, is that you don't program with side effects. You don't have that at all, that you always synthesize the results or partial results that become larger partial results that eventually become the result that you're interested in. And only then are you allowed to print it to the screen to see what the answer to the problem was. Okay? It's very difficult to explain scheme if you've never seen it before in a five minute segment of a full introduction. But when you get there, we have tons of examples of the paradigm. It's a very fun, neat little language to work in. I think it's the easiest language of all four up there because it's such a small language. Once you get the paradigm down and you understand how to program functionally, scheme is not that bad at all. It's actually very fun. Okay? Not that all programming is fun, but scheme is particularly fun. Okay? Now, I used to teach either some advanced C++ or more recently some Java toward the end of the course. Last quarter, I decided literally in the eighth week that I was going to not do Java because 108 is all about Java, and I felt like I was stealing the thunder from 108. So I just said, you know what? I'm going to teach Python. Let's see how it works out. And I turned it at work fairly well, certainly considering I had never really taught it before. But this language called Python, I'm suspecting most people have heard of it, even if they've never seen it, it seems to be the rage language at a lot of significant companies in the Bay Area. They're very smart people of these companies. So when they use language and they like it, there's usually a very good reason for them liking it. You've probably heard of a language called Pearl. Okay? It's not a very pretty language. You can just think about in some sense, Python being a more modern, object-oriented version of Pearl. Okay? I don't know, Pearl, you don't know Python. It doesn't mean anything to you. But just understand that this is the sexy little language that's been around for probably 16, 17 years, that's really established itself as a popular language since year 2000, 2001. I know a lot of people who work at Google that program in Python on a daily basis. There's a subset of us at Facebook, the program in Python every day, doing a lot of distributed systems work, and just Python seems to be the way to go for that right there. It actually has a lot of good libraries for dealing with web programming. Web programming can seem really boring to a lot of people because it just seems like it's HTML and web pages and things like that. Real web programming is more sophisticated than that. You dynamically generate web pages based on content and databases and things like that. And Python being a scripting language, which means it's interpreted and it kind of, you can type in stuff as you go and it recognizes and reads and executes the stuff as you type. It's very good for that type of thing and if all goes well, meaning I have time to develop this assignment I have, this assignment idea I have, you're going to write a little miniature dynamic web server in Python for your final project. It won't be vax sophisticated. You're not going to write all of Apache, but you are going to probably write some little thing where you really do have a web server behind the scenes, making decisions about how to construct an HTML page and serve that over to a client. So it'll be an opportunity to learn Python, to learn its libraries, to see that as a language because it's fairly young, it has the advantage of not bothering to include C and C++'s and Java's mistakes. So it says, no, I'll leave that part out and I'll go with this more interesting, well-formed core. It has great libraries. It has object orientation. You can program, procedurally if you want to and just program like you're in C using Python syntax. There are even functional programming aspects in the language. So even though the syntax is different from scheme, conceptually you can use scheme like ideas in Python code if you want to. I'll be able to illustrate the client server paradigm and how it's different from traditional programming. That's not so much a Python thing, but Python is a good vehicle for learning that stuff. I'll show you the library so that you can parse XML and HTML and you can understand the HTTP protocol and all of this stuff and just to actually read blogs, to download RSS files, all of these things that are very, very gracefully handled by Python programs. So that's where I'm hoping to take people by week 10 of the course. Okay? Does that make sense? Okay. There are a few other paradigms that aren't represented here, but I think I really cover all the ones that you're likely to see for the next 15 years if you go out in your repellent. There are a couple of the languages I may briefly mention in the last day that are just fun, but they all have some overlap with some language that's represented right here. Okay? You guys are good? Okay. So I don't like starting in on any real material when I only have 10 minutes left, so I'm actually going to let you go. But I recognize that Friday, I'm going to have tons of handouts for you. I'm going to have an assignment. Okay. We're going to dive right into the low level pointer stuff of CNC++. Okay? So have a good week. Okay? Okay.