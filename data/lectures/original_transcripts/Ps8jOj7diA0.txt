this presentation is delivered by the stanford center for professional development. jerry cain: okay. here is, uh, in a nutshell, a reduced version of what's presented in handout two. this is the syllabus. i have, umm, several languages i'm gonna put on the board and, uh, one concept: c, assembly, c++, concurrent programming-- that's not a language, that's just a paradigm- - umm, scheme, and then, it is official, i'm actually gonna cover python from now on in 107. people look at this and they go, "wow. i'm gonna be able to legitimately put all these languages on my resume." okay. and it's on a separate list on the bottom and it feels real good. it isn't so much about that. certainly what-- we wanna give you some mileage in some relevant languages that are very good, umm, for both research and for industry, but the real intellectual value in learning all these languages is to really study the paradigms that they represent. and i'll explain with that means in a second. but to program in c or c++, it's almost a different thought- - you're following a different thought process that you are when you program in scheme or in python. okay? you all know enough c++, and believe it or not you know enough c already, just take out the object orientation from c++ and you're more or less left with c. umm, when you program in c, pure c and you have no classes, you're very procedure-- procedure-oriented, you think of the main function as being a high-level out line of maybe five top-level functions to call and those five functions each have sub functions and those sub functions have sub sub functions, etc. does that make sense? it's like a bit like-- it's like outline for history-- outline to notes for history class where you have roman numeral one in main and roman numeral two in main, and roman numeral three in main, and then you have small a and b, and maybe little i's and things like that. you understand what i'm getting at? okay? your origin to run the procedures, okay. you program with side effects, you pass around references and pointers with the idea of updating shared data. okay? you do that both in c and c++. but as far as c is concerned, this represents, uh, what's called the procedural paradigm. you also hear it called the imperative paradigm. it is verb-oriented in the sense that the first thing you ever see-- or you typically see with a statement is the function call, okay, where the function name is usually has some strong verb in it so it gives you some idea as to what the function's supposed to accomplish. okay? does that make sense to people? when you study c++ and all of a sudden rather than calling do this and passing the address of some object, you do my object arrow do this. does that make sense? okay. then all of a sudden the first thing you see on that line is the data or the object that's being manipulated and because the first thing you see is the object, that's why it's object-oriented as opposed to procedure-- procedurally- oriented. okay? does that make sense to people? okay. i think a lot of c++ programmers really program in c and just incidentally use the objects in classes that are available to them. okay? which is a perfectly reason way to program. most people learned how to program in c. most people i know in industry know c very, very well and in spite of the fact that there's many newer languages that are better in most regards, they still stick with what they know and that's why c and c++ are still such popular languages. there's nothing wrong at all with programming in c if you really know it very well, and you write clean, readable code. it's just more difficult-- i'm sorry. let's say it this way: it's much easier to make memory errors in c because everything is exposed and there's very little error checking going on. c++ is a little bit better about it. in between here i have this thing called assembly. i haven't decided whether i'm gonna go with what i've gone with for the past seven or eight years, which is this mock assembly language, or i'm really going to take a step and teach you a real-- i don't wanna say-- it's a real assembly language although you don't see it's if use very much. but there's an assembly language called mips and it's very easy, as far as assembly languages go to learn. uh, i don't want really care so much about teaching you how to program in assembly. i use it as a vehicle for showing you how c and c++ programs compile to .o and object files into binaries and eventually become executables, and show you how a line like i equals seven or j plus plus, or, umm, foo of x and y as a function call, how that all translates to assembly code. okay? does that make sense? i mean, you know that when you write c++ code that you-- when you execute the program it's not c++ anymore. it's assembly code. it's all zero's and one's eventually. i wanna give you some insight as to how c is translated to assembly code, how all your variables, and your functions, and your objects, and all of that eventually get boiled down and hashed down to a collection of zero's and one's. and i wanna do a little bit of the same thing for c++. it turns out that while c++ and c represent different paradigms that they really also compile to zero's and one's and after you get enough experience with this assembly and the manual compilation process that we're gonna learn about as in how to look at c code and figure out what the assembly code would look like, you're really gonna see that c++ and c almost look like the same language as far as the zero's and one's are concerned. okay? we're really just gonna extend the compilation model we use for going from c to assembly to accommodate c++ references, and classes, and templates, and things like that are new to the language compared c. and you have, i think, have a very, very good understanding of how c and c++ work after the first five weeks of the course. okay? and it makes you so much better of a c and c++ programmer. we're gonna demystify this whole pointer thing, i'm gonna do something, like, asterisk, asterisk, ampersand, asterisk, asterisk, p, arrow, asterisk, asterisk, asterisk equals seven and you're gonna know exactly what it means. okay? &gt;&gt; jerry cain: and so it takes a little bit of work and it's almost laughable how arbitrary you can be with all your casts, and your ampersands, and with your asterisks. but if it compiles it means something so when it runs it actually does something. it's probably not good if you have a lot of asterisks and ampersands but nonetheless you can have some idea as to why it's crashing not just that it is crashing. okay? i spend a good amount of energy talking about concurrent programming. we actually at the moment do that type of programming in c but all the programs you've written in the past two quarters if you've just taken the 106a and 106b courses here or 106x, all the programs you've written at stanford prior to 107 have been sequential programs. which means that there is-- whether it's object oriented or imperative-- procedurally oriented-- you have this outline of steps that happen one after another. okay? nothing's done in parallel, or pipeline, or done side by side. everything happens in one clean stream of instructions. okay? well, what concurrent programming is about is within a single program, trying to get two functions to seemingly run simultaneously. okay? and if you can get two functions to seemfully run simultaneously then you can extend that and get ten functions to run simultaneously, or 20 functions to run simultaneously, or seemingly simultaneously. i say it that way because technically they don't run at the same time. when i go over assembly code-- and i think get into it enough to know what assembly code is like, but if you have this one function, okay, my hand is a function. this hand is another function. okay? and you concern yourself with the execution of one of them, then when i do this you can just think about it reading the code and executing it for side effects. does that make sense to people? when you deal with concurrent programming you have two or more functions-- just two right here because i only have two hands-- to do this and they both seemingly run at the same time. okay? but what really happens is it's like watching two movies at the same time where, because there's only one processor on most machines, it doesn't really run like this. it runs like this and switches back and forth between the two functions. but it's happened so fast that you can't see the difference. okay? it's more than 24 frames per second. it is like a million. okay? and you're watching two movies at the same time, okay? and that extends just fine to three, to five, to ten, to 100 in theory. okay? there are a lot of situations where concurrent programming is really not very useful but there are several situations, particularly networking whenever that's involved, umm, where concurrent programming is actually very useful. there are some problems that come up when you deal with concurrent programming that you might not think about. umm, the example i always go over the first day of class is just it uses two wells fargo atm machines. okay? think about you have a wells fargo checking account-- you may not have to think about it because you do-- so just imagine your wells fargo checking account is in danger because two computers in atm machines, and you have a hundred dollars in it. okay? and you share your pin with your best friend and you go up to neighboring atm machines and you make as much progress as possible to withdraw that $100, okay, and then you both on the count of three press okay to try to get $200 collectively. does that make sense? that is not a nonsensical example because both of those machines are basically very simple computers, okay, that ultimately need access the same master account balance to confirm that $100 is available and in this transactional way-- transactional makes sense both in terms of money and also in a sense of concurrent programming. you have to make sure that the $100 being identified as the account ambulance, umm, is maintained with some-- some atomic flavor so that if you have two people trying to withdraw $100 at the same time that only one person gets away with it. that $100 account balance is the shared resource that two different processes have access to. does that make sense to people? okay. so, there have to be directives that are put in place to make sure that the account balance check and the withdrawal are basically done not at all or in full so that it really does function truly as a transaction, both in the finance and in the programming sense. okay? if you're sloppily about it-- i don't mean sloppily. that's not a very nice thing to say on the first day. if you're not careful about how you actually program using-- program concurrently, you can actually come up with problems and have these data integrity issues which banks are actually very, very, umm, worried about obviously. they don't wanna give out $10 million with they only have $1 million. okay? same thing with, like, airlines. if they have one seat remaining on a flight and two people call and try to get that seat they only wanna give it to one person. now, it would seem that they don't care about concurrent programming 'cause they're more than happy to give you a seat that doesn't exist on the plane. okay? but the airline's problems are probably not related to concurrent programming. okay? umm, as far as the scheme and python thing are concerned, once we get through concurrent programming, uh, we really switch gears and we start looking at this language called scheme. you may not have heard of this. if you haven't heard of this you may have heard of a language called lisp, which, uh, it's certainly related to. this is a representative of, umm, what is called the functional paradigm. okay? there's two things about scheme and functional languages-- purely functional languages-- that are interesting in contrast to c and c++. when you program using the functional paradigm you always rely on the return value of a function to move forward. okay? and you program without side effects. now, that's a very weird thing to hear as an expression when you've only coded for a year. but when you code in c and c++, it's very often all about side effects. the return value doesn't always tell you very much. it's a number or it's a bullion. but when you pass in a data structure by reference to a function and you update it so that when the function returns the original data structure's been changed. right? does that make sense? that's programming by side effect. well, the idea with scheme and particularly the functional paradigm is that you don't program with side effects. you don't have that at all. that you always synthesize with results or partial results that become larger partial results that eventually become the result that you're interested in and only then are you allowed to print it to the screen to see what the answer to the problem was. okay? umm, it's very difficult to explain scheme if you've never seen it before in a five-minute segment of a full introduction. but when you get there, umm, we have tons of examples of the paradigm. it's a very fun, neat little language to work in. i think it's the-- i think it's the easiest function of all four up there because it's such a small language. once you get the paradigm down and you understand how to program functionally, scheme is not that bad at all. it's actually very fun. okay? not that all programming isn't fun but scheme is particularly fun. okay? now, i used to teach either some advanced c++ or recently some java toward the end of the course. last quarter i decided literally in the eighth week that i was gonna not do java because 108 is all about java and i felt like i was stealing the thunder, umm, from 108. so, i just decided, you know what? i'm just gonna teach python and see how that works out. and it worked out well certainly considering i'd never really taught it before. but this language called python-- i'm suspecting most people have heard of it even if they haven't seen it. it seems to be the rage language at a lot of significant companies in the bay areas. they're very smart people at these companies so when they use a language and they like it, there's usually a very good reason for them liking it. you've probably heard of a language called pearl. okay? it's not a very pretty language. uh, you can just think about, in a sense, python being a more modern object-oriented version of pearl. okay? and i know if you don't know pearl and you don't know python it doesn't mean anything to you but just understand that this is the sexy little language has been around for probably 16, 17 years that's really established itself as a popular language since year 2000, 2001. i know a lot of people who work at google that program in python on a daily basis. there are a subset of us at facebook that program in python every day doing a lot of distributing systems work and python just seems to be the way to go for that right there. uh, it actually has, uh, a lot of good libraries for dealing with web programming. umm, web programming can seem really boring for a lot of people because it seems that it's just html and web pages and a lot of things like that. real web programming is more sophisticated than that. you dynamically generate web page s based on content in data bases and things like that. and python, being an encrypting language, meaning it's interpreted and you can type in a language and stuff as you go and it recognizes, and reads, and executes the things as you type, it's very good for that type of thing. and if all goes well, meaning i have type to develop this new assignment i have an idea-- this new assignment idea i have, umm, you're gonna write a little-- a miniature web server in python for your final project. it won't be that sophisticated. you're not gonna write all of apache. but you are probably gonna write some little thing where you really do have a web server behind the scenes making decisions about how to construct an html page and serve that over to a client. so it'll be an opportunity to learn python, learn its libraries, to see, as a language, because it's fairly young it has the advantage of not bothering to include the c and c++'s and java's mistakes. so, i'll leave all that stuff out and go with this more interesting, well-formed core. it has great libraries, umm, it has object orientation. you can program procedurally if you want to and just program as if you're in c but using python syntax. there are even functional programming aspects in the language. so, even though the syntax is different than scheme, conceptually you can use scheme-like ideas in python code if you want to. okay? i'll be able to illustrate the client/server paradigm and how it's different from traditional programming. uh, that's not so much a python thing, but python's a good vehicle for learning that stuff. i'll show you the library so that you can parse xml and you can parse ht-- and you can understand http protocol, umm, and all of this stuff-- and just to actually read blogs, to download rss files, all of these things that are very, very gracefully handled by python programs. okay? and so that's where i'm hoping to take people by week ten of the course. okay? does that make sense? okay. there are a few other paradigms that aren't represented here but i think i really cover all the ones that you're likely to see for the next 15 years if you go out and you're a coder. okay? there are a couple of languages that i may briefly mention in the last day that are just fun but they all have some overlap with some language that's represented right here. okay? you guys are good? okay. so, i don't like starting in on any real material when i only have ten minutes left so i'm actually going to let you go. but recognize that friday i'm gonna have tons of handouts for you, i'm gonna have an assignment. okay? we're gonna dive right into the the low-level pointer stuff of c and c++. okay? so have a good week.